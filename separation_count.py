"""
separation_count.py - Cameron Johnston
This script takes a dump file from a LAMMPS script to be read by VMD
and counts at each timestep the number of hydrogen bonds between the
two DNA chains. At the start, all pairs will be bonded but as chains
separate this number will decrease. The number of H bonds will be
plotted against time.
"""

import numpy as np
import math as m
import sys
import matplotlib.pyplot as pl
import copy

# Sets rc, value above which bond is considered broken
rc = 1.8

def reshape(array, no_atoms):
	# Method to make sure position array is in correct format
	# Ensures all values are floats instead of strings
	array = array.astype(float)
	# Puts array in correctn shape
	array = np.reshape(array, (int(no_atoms/2), 5))
	# Sorts rows by atom number
	array = array[array[:,0].argsort()]
	# Deletes atom number and atom type columns
	array = np.delete(array, (0,1), 1)
	return array
	
def count(array1, array2, x_len, y_len, z_len):
	# Method to count number of remaining bonds at timestep
	# Calculates distance between atom i in chain 1 and atom (N+i)
	# in chain 2. Has to multiply by box size because positions are
	# given as fraction of box size
	separations = np.sqrt((x_len*(array1[:,0] - array2[:,0]))**2 + 
							  (y_len*(array1[:,1] - array2[:,1]))**2 +
							  (z_len*(array1[:,2] - array2[:,2]))**2)
	# Value to be updated for every remaining bond
	bonded = 0
	# Every value in separations array is checked
	for k in range(separations.size):
		if separations[k] < rc:
			bonded = bonded + 1
	return bonded

def main():
	
	# Opens input file generated by LAMMPS
	dumpfile = open(sys.argv[1],'r')
	lines = dumpfile.readlines()

	for i in range(len(lines)):
		# Puts file in format to be read and creates array for each line
		lines[i] = lines[i].strip()
		lines[i] = lines[i].split(" ")
		lines[i] = np.array(lines[i])

	# Finds length of file
	len_dump = len(lines)
	# Number of atoms (constant) is printed at each timestep so only 
	# need to check first timestep
	no_atoms = int(lines[3])
	# Takes Umin value from dump file name which must have correct
	# format: 'dump.denaturation.<Umin>'
	Umin = float(dumpfile.name.strip("dump.denaturation."))
	# Takes box size (contant) from dump file in same way as no_atoms
	x_len = abs(float(lines[5][0]) - float(lines[5][1]))
	y_len = abs(float(lines[6][0]) - float(lines[6][1]))
	z_len = abs(float(lines[7][0]) - float(lines[7][1]))
	
	# Creates empty arrays for plot
	times = np.array([])
	bonds = np.array([])

	# Finds timestep number. There are 9 lines of extra information for
	# each timestep which need to be excluded
	for i in range(len_dump):
		if ((i)%(no_atoms+9)) == 0:
			times = np.append(times, float(lines[i+1]))
	
		# Finds first line of atom postions for timestep 
		elif ((i)%(no_atoms+9)) == 9:
			# Creates empty position arrays with one for each chain
			# and sorts atom positions into correct array by atom
			# type label
			positions1 = np.array([])
			positions2 = np.array([])
			for j in range(no_atoms):
				lines[i+j][0] = int(lines[i+j][0])
				if lines[i+j][1] == '1':
					positions1 = np.append(positions1, lines[i+j])
				if lines[i+j][1] == '2':
					positions2 = np.append(positions2, lines[i+j])
				
			# Uses reshape and count methods to count bonds
			positions1 = reshape(positions1, no_atoms)
			positions2 = reshape(positions2, no_atoms)
				
			bonded = count(positions1, positions2, x_len, y_len, z_len)
			bonds = np.append(bonds, bonded)
	
	# Converts number of bonds remaining to a fraction of initial bonds
	bond_frac = bonds/(no_atoms/2)
	# Creates truncated array removing first million timesteps
	bond_frac_trunc = np.array([])
	for i in range(times.size):
		if times[i] >= 1000000:
			bond_frac_trunc = np.append(bond_frac_trunc, bond_frac[i])
	# Averages fraction of bonds across timesteps above 1 million	
	ave_bond = np.average(bond_frac_trunc)
	# Finds standard deviation for this value
	dev_bond = (bond_frac_trunc - ave_bond)**2
	sd_bond = np.sqrt(np.sum(dev_bond)/(dev_bond.size - 1))

	# Plots average fraction of remaning bonds, theta, against
	pl.plot(times, bond_frac)
	pl.axhline(y = ave_bond, color = 'r', linestyle = '--',
		label = (r"Average $\theta$ for timesteps after 1,000,000 = "+str(round(ave_bond, 3))))
	pl.xlabel("Number of timesteps")
	pl.ylabel(r"$\theta$"+ " with "+r"$N=$"+str(int(no_atoms/2))+" and "+r"$U_{min}=$"+str(Umin))
	pl.legend()
	pl.show()
	
	# Appends data to given data file
	datafile = open(sys.argv[2], 'a')
	datafile.write("{}	{}	{}\n".format(Umin, ave_bond, sd_bond))

main()
